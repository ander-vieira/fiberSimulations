function sigma = generateGaussianSigma(lambdaVals, cVals, deltaWVals)
%GENERATEGAUSSIANSIGMAS Generate a sigma using Gaussian curves
%   Takes the parameters that define a number of Gaussian functions
%   and returns a function handle that generates the resulting sigma
%   as a function of wavelength.
%   All of this function's parameters can be generated by applying
%   gaussianSigmasMC to an existing sigma function (sigmaabs or sigmaemi)
%   The advantage of generating sigmas like this instead of using the
%   experimental ones is the tails: the functions become small but not
%   negligible, and the experimental values are missing these tails due to
%   experimental noise/error
%
%   Parameters:
%   lambdaVals: center wavelengths for each Gaussian (m)
%   cVals: maximum values for each Gaussian (m^2)
%   deltaWVals: standard deviations for each Gaussian (s^-1)
%
%   Example calls:
%   sigmaabs = generateGaussianSigma([425.58e-9;449.42e-9;473.00e-9], [5.34569e-21;1.008615e-20;4.559433e-21], [4.36275e14;2.43868e14;1.19762e14]);
%   (a generated absorption sigma for Coumarin 6)
%   sigmaemi = generateGaussianSigma([494.76e-9;514.39e-9;552.96e-9]-52e-9, [3.39061e-21;4.71290e-21;1.37855e-21], [1.3014e14;2.40312e14;3.02088e14]);
%   (a generated emission sigma for Coumarin 6)

h = 6.63e-34; % JÂ·s
c = 3e8; % m/S

% The Gaussian functions are functions of frequency, not wavelength
wVals = 2*pi*c./lambdaVals;

% Generate the sigma for frequency values (sum all the Gaussian bells)
sigmaW = @(ww) sum(cVals.*exp(-(ww-wVals).^2./deltaWVals.^2));

% Do the conversion from wavelength to frequency
sigma = @(ll) sigmaW(2*pi*c./ll);

end